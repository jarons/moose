#!/usr/bin/env python
from TestHarness import TestHarness
from TestHarness import util
import mock
import os, sys, unittest

class TestHarnessTestCase(unittest.TestCase):
    def setUp(self):
        """
        setUp occurs before every test.

        Clean up previous session file and build a new set of jobs.
        """
        self.pbs_session_file = os.path.join(os.getenv('MOOSE_DIR'), 'test', 'unittesting_pbs')

        try:
            # remove previous session file if exists
            os.remove(self.pbs_session_file)
        except:
            pass

        self.test_file = os.path.join(os.getenv('MOOSE_DIR'), 'test','tests', 'test_harness', 'queue_job')

    def tearDown(self):
        """
        tearDown occurs after every test.

        Clean up old session file. Otherwise, when instancing the
        QueueManager with the presence of a session file, we trigger
        a checkStatus stage by default.

        We want to control this manually using mock.
        """
        try:
            # remove session file before each test
            os.remove(self.pbs_session_file)
        except:
            pass

    def createHarnessAndTesters(self, test_file):
        """
        Return a tuple of the TestHarness, and the list of testers
        generated by the supplied test_file.
        """

        ### We need to simulate what run_tests would do. Meaning, we need to
        ### instance the TestHarness while being in the directory where run_test
        ### sits. This is needed so tester's TestName is properly set (TestHarness
        ### takes the path leading up to run_tests, strips this off, and the
        ### results is what makes up the actual TestName).
        saved_cwd = os.getcwd()
        run_tests_dir = os.path.join(os.getenv('MOOSE_DIR'), 'test')
        os.chdir(run_tests_dir)

        # Instance the TestHarness
        harness = TestHarness(['foo', '--pbs', self.pbs_session_file], 'moose', os.getenv('MOOSE_DIR'))

        ### With the TestHarness properly instanced we now need to simulate
        ### what findAndRunTests does by changing into each tester directory
        ### before asking the factory to parse the file.
        tester_dir = os.path.dirname(test_file)
        tester_file = os.path.basename(test_file)
        sys.path.append(tester_dir)
        os.chdir(tester_dir)

        # Create testers
        testers = harness.createTesters(tester_dir, tester_file, False)

        ### change back to original dir
        os.chdir(saved_cwd)
        sys.path.pop()

        return (harness, testers)

    @mock.patch.object(util, 'formatResult')
    def _mockPBSLaunch(self, mock_result):
        """
        Create the TestHarness and simulate a qsub job launch return as if
        we had launched it with a PBS job scheduler.
        """
        (harness, testers) = self.createHarnessAndTesters(self.test_file)
        with mock.patch.object(util, 'runCommand') as mock_run:
            # A proper return value for qsub command
            mock_run.return_value = '1.nowhere.org'

            # Instruct the TestHarness to schedule tests
            harness.scheduler.schedule(testers)
            harness.scheduler.waitFinish()

        return mock_result.call_args

    @mock.patch.object(util, 'formatResult')
    def _mockPBSStatus(self, qstat_status, mock_result):
        """
        Create the TestHarness and simulate a qstat status.
        """

        # Launch the initial job to create a session_file
        self._mockPBSLaunch()

        # Re-initialize the scheduler to trigger a status check
        (harness, testers) = self.createHarnessAndTesters(self.test_file)

        # patch runCommand to return requested status_expression
        with mock.patch.object(util, 'runCommand') as mock_run:
            mock_run.return_value = qstat_status
            harness.scheduler.schedule(testers)
            harness.scheduler.waitFinish()

        return mock_result.call_args

    def testPBSLaunch(self):
        """
        Test QueueManager's ability to launch a PBS job using qsub
        """
        reg_exp = 'LAUNCHED 1'
        (result, kwargs) = self._mockPBSLaunch()
        self.assertRegexpMatches(result[1], reg_exp)

    def testPBSQueued(self):
        """
        Test QueueManager's ability to detect a PBS status using qstat
        """

        # Note: PBS only uses the first letter for each statuses in the
        # following list.
        status_list = ['RUNNING', 'EXITING', 'QUEUED', 'HOLDING']

        for status in status_list:
            status_return = 'job_state = %s' % (status[0])
            print('Checking for %s' % (status))
            (result, kwargs) = self._mockPBSStatus(status_return)
            self.assertRegexpMatches(result[1], status)

            # We need to destroy the session file for every iteration
            # because of the saftey-logic involved preventing jobs from
            # launching multiple times... this is way cleaner.
            self.tearDown()

    def testQueueCleanup(self):
        """ Test the QueueManagers ability to clean up after itself """

        # Create a mess to clean up
        self._mockPBSLaunch()

        tester_dir = os.path.dirname(self.test_file)
        session_dir = 'job_' + os.path.basename(self.pbs_session_file)

        # See if we actually made a mess, like we should have
        if os.path.exists(os.path.join(tester_dir, session_dir)):
            harness = TestHarness(['foo', '--queue-cleanup', self.pbs_session_file], 'moose', os.getenv('MOOSE_DIR'))

            # Perform the clean up code
            harness.scheduler.cleanUp()
            if os.path.exists(os.path.join(tester_dir, session_dir)):
                raise Exception('Failed to perform queue cleanup')

        else:
            raise Exception('Session location does not exist: %s' % (os.path.join(tester_dir, session_dir)))

if __name__ == '__main__':
    unittest.main(verbosity=2)
